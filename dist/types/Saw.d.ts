import Matches from './Matches';
type MatcherFn = (s: string) => RegExpMatchArray | null;
type Matcher = string | RegExp | MatcherFn;
export type SawInput = number | string | string[] | Matches;
export default class Saw {
    private _context;
    constructor(object: SawInput | undefined);
    match(match: Matcher | Matcher[]): Saw;
    matchAll(match: RegExp): Array<Record<string, string> | string[]>;
    has(match: Matcher | Matcher[]): boolean;
    item(index: number): Saw;
    itemFromRight(index: number): Saw;
    first(): Saw;
    last(): Saw;
    replace(match: string | RegExp | (string | RegExp)[], replacement: string | ((substring: string, ...args: any[]) => string)): Saw;
    join(separator: string | ((item: string, index: number, array: string[]) => string)): Saw;
    each(func: (item: string, index: number, array: string[]) => any, thisArg?: unknown): Saw;
    map<T = string>(func: (item: string, index: number, array: string[]) => T, thisArg?: unknown): Saw;
    reduce(func: (previousValue: any, currentValue: string, index: number, array: string[]) => any, thisArg?: unknown): Saw;
    reverse(): Saw;
    sort(func?: (a: string, b: string) => number): Saw;
    prepend(string: string): Saw;
    append(string: string): Saw;
    capitalize(): Saw;
    lowerCase(): Saw;
    upperCase(): Saw;
    private mapStringMethodAgainstContext;
    find(match?: Matcher, thisArg?: unknown): Saw;
    filter(match?: Matcher, thisArg?: unknown): Saw;
    filterNot(match?: Matcher, thisArg?: unknown): Saw;
    remove(...matchesToRemove: Array<string | RegExp>): Saw;
    uniq(): Saw;
    trim(): Saw;
    split(separator: string | RegExp): Saw;
    slice(begin?: number, end?: number): Saw;
    transform<T = unknown>(func: (context: any) => T): Saw;
    toString(): string;
    toArray(): string[];
    toNumber(): number;
    toFloat(): number;
    toInt(): number;
    toBoolean(): boolean;
    toObject(...props: Array<string> | [string[]]): Record<string, string>;
    startsWith(match?: string): boolean;
    endsWith(match?: string): boolean;
    indexOf(match: string | RegExp | ((item: string) => boolean)): number;
    indexesOf(match: string | RegExp | ((item: string) => boolean)): number[];
    length(): number;
    private _contextToString;
}
export {};
